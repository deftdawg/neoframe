<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Dithering to Epaper</title>
    <style>
        /* latin */
        @font-face {
        font-family: 'Orbitron';
        font-style: normal;
        font-weight: 400;
        font-display: swap;
        src: url(https://fonts.gstatic.com/s/orbitron/v35/yMJMMIlzdpvBhQQL_SC3X9yhF25-T1nyGy6BoWgz.woff2) format('woff2');
        unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a2e;
            color: #e5e5e5;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            font-family: 'Orbitron', sans-serif;
            color: #00adb5;
            margin: 10px 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 5px rgba(0, 173, 181, 0.7);
            text-align: center;
        }
        .page-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 90%;
            max-width: 1800px;
        }
        .controls-container {
            background-color: #16213e;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 100%;
            box-sizing: border-box;
            margin-bottom: 20px;
        }
        .file-upload-container {
            position: sticky;
            top: 10px;
            z-index: 100;
            background: #16213e;
            padding: 10px 0;
            border-radius: 8px;
            text-align: center;
        }
        label.file-label {
            display: inline-block;
            padding: 12px 24px;
            background-color: #00adb5;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s;
            font-size: 1.1em;
        }
        label.file-label:hover {
            background-color: #007f91;
            transform: scale(1.05);
        }
        input[type="file"] {
            display: none;
        }
        select, input[type="range"] {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            border: none;
            outline: none;
            font-size: 1em;
            background-color: #1f4068;
            color: #e5e5e5;
            margin-bottom: 10px;
        }
        #canvas {
            border: 2px solid #00adb5;
            border-radius: 8px;
            margin: 15px auto;
            display: block;
            max-width: 100%;
            height: auto;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background-color: #00adb5;
            color: white;
            cursor: pointer;
            font-weight: bold;
            margin: 5px;
            transition: background-color 0.3s ease, transform 0.2s;
            font-size: 1em;
        }
        button:hover {
            background-color: #007f91;
            transform: scale(1.05);
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        .slider-container label {
            flex: 0 0 100px;
            font-size: 0.9em;
        }
        .controls-group {
            margin-bottom: 15px;
        }
        .controls-group label {
            display: block;
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        .ip-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #esp32-ip {
            flex-grow: 1;
            padding: 8px;
            border-radius: 5px;
            border: none;
            background-color: #1f4068;
            color: #e5e5e5;
        }

        #online-status-indicator {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background-color: #6c757d; /* Grey - default/checking */
            transition: background-color 0.5s ease;
            flex-shrink: 0;
        }

        #online-status-indicator.online {
            background-color: #28a745; /* Green */
        }

        #online-status-indicator.offline {
            background-color: #dc3545; /* Red */
        }

        #status-container {
            font-size: 0.8em;
            margin-top: 8px;
            color: #aaa;
        }
        #progressBar {
            width: 100%;
            height: 8px;
            background-color: #333;
            border-radius: 5px;
            margin-top: 15px;
            overflow: hidden;
        }
        #progressBar > div {
            height: 100%;
            background-color: #00adb5;
            width: 0;
            transition: width 0.3s;
        }
        #log {
            margin-top: 15px;
            padding: 10px;
            background-color: #1f4068;
            border-radius: 8px;
            max-height: 150px;
            overflow-y: auto;
            font-size: 0.9em;
            line-height: 1.4;
        }
        .back-to-top {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 15px;
            background-color: #00adb5;
            color: white;
            border-radius: 50%;
            cursor: pointer;
            /* display: none; */
            transition: background-color 0.3s ease;
        }
        .back-to-top:hover {
            background-color: #007f91;
        }
        @media (max-width: 600px) {
            h1 {
                font-size: 2em;
            }
            .controls-container {
                padding: 10px;
            }
            button, label.file-label {
                padding: 10px 15px;
                font-size: 0.9em;
            }
            .slider-container label {
                font-size: 0.8em;
                flex: 0 0 80px;
            }
            select, input[type="range"] {
                font-size: 0.9em;
            }
        }
    </style>
    <script src="scripts/exif.js"></script>
    <script type="text/javascript" src="scripts/qrcode.js"></script>
</head>
<body>
    <div class="page-container">
        <div class="controls-container">
            <h1>NeoFrame</h1>
            <div class="file-upload-container">
                <label for="upload" class="file-label">Upload Image</label>
                <input type="file" id="upload" accept="image/*">
            </div>
            <div class="controls-group">
                <label for="esp32-ip">ESP32 IP Address:</label>
                <div class="ip-container">
                    <input type="text" id="esp32-ip" value="192.168.4.1" placeholder="Enter ESP32 IP Address">
                    <div id="online-status-indicator" title="Status: Unknown"></div>
                </div>
                <div id="status-container">
                    <span>Last Online: <span id="last-online-time">N/A</span></span>
                    <span style="margin: 0 5px;">|</span>
                    <span>Last Checked: <span id="last-checked-time">N/A</span></span>
                </div>
            </div>
            <div class="controls-group">
                <label for="ditherMode">Colors Mode:</label>
                <select id="ditherMode">
                    <option value="sixColor" selected="selected">Six Colors</option>
                    <option value="fourColor">Four Colors</option>
                    <option value="blackWhiteColor">Black &amp; White</option>
                    <option value="threeColor">Three Colors</option>
                </select>
            </div>
            <div class="controls-group">
                <label for="ditherType">Dithering Mode:</label>
                <select id="ditherType">
                    <option value="floydSteinberg" selected="selected">Floyd-Steinberg</option>
                    <option value="atkinson">Atkinson</option>
                    <option value="stucki">Stucki</option>
                    <option value="jarvis">Jarvis-Judice-Ninke</option>
                </select>
            </div>
            <div class="controls-group">
                <label for="rotation">Rotate:</label>
                <select id="rotation">
                    <option value="0" selected="selected">0 degrees</option>
                    <option value="90">90 degrees</option>
                    <option value="180">180 degrees</option>
                    <option value="270">270 degrees</option>
                </select>
            </div>
            <div class="controls-group">
                <label for="scaling">Scaling: <span id="scale-percentage"></span></label>
                <select id="scaling">
                    <option value="fill" selected="selected">13.3: Fill</option>
                    <option value="fit">13.3: Fit</option>
                    <option value="fill_8x10">8x10: Fill</option>
                    <option value="fit_8x10">8x10: Fit</option>
                    <option value="original">100% (Original Size)</option>
                    <option value="custom">Custom Percentage</option>
                </select>
            </div>
            <div class="slider-container" id="custom-scaling-container" style="display: none;">
                <label for="customScale">Custom Scale:</label>
                <input type="range" id="customScale" min="10" max="200" step="1" value="100">
                <input type="number" id="customScaleNumber" min="10" max="200" value="100" style="width: 70px; margin-left: 10px;">
                <button class="quick-scale" data-scale="50">50%</button>
                <button class="quick-scale" data-scale="100">100%</button>
                <button class="quick-scale" data-scale="200">200%</button>
            </div>
            <div class="slider-container">
                <label for="ditherStrength">Dither Strength:</label>
                <input type="range" id="ditherStrength" min="0" max="5" step="0.1" value="1.0">
            </div>
            <div class="slider-container">
                <label for="contrast">Contrast:</label>
                <input type="range" id="contrast" min="0.5" max="2" step="0.1" value="1.2">
            </div>
            <div class="controls-group">
                <label for="qr-code-toggle">
                    <input type="checkbox" id="qr-code-toggle" style="margin-right: 8px;">Enable QR Code Overlay
                </label>
            </div>
            <div id="qr-code-options" style="display: none;">
                 <div class="controls-group">
                    <label for="qr-content-type">QR Code Content:</label>
                    <select id="qr-content-type">
                        <option value="url" selected>Browser's Current Address</option>
                        <option value="exif">Picture EXIF Metadata</option>
                        <option value="wifi">Device WiFi Connection</option>
                        <option value="custom">Custom Text</option>
                    </select>
                </div>
                <div class="controls-group" id="qr-custom-text-container" style="display: none;">
                    <label for="qr-custom-text">Custom Text:</label>
                    <textarea id="qr-custom-text" rows="3" style="width: 100%; background-color: #1f4068; color: #e5e5e5; border-radius: 5px;"></textarea>
                </div>
                <div class="controls-group">
                    <label for="qr-position">Position:</label>
                    <select id="qr-position">
                        <option value="bottom-right" selected>Bottom Right</option>
                        <option value="bottom-left">Bottom Left</option>
                        <option value="top-right">Top Right</option>
                        <option value="top-left">Top Left</option>
                    </select>
                </div>
                <div class="controls-group">
                    <label for="qr-margin">Margin (px):</label>
                    <input type="number" id="qr-margin" value="20" min="0" style="width: 100%; padding: 8px; border-radius: 5px; border: none; background-color: #1f4068; color: #e5e5e5;">
                </div>
                <div class="controls-group">
                    <label for="qr-color">QR Code Color:</label>
                    <select id="qr-color"></select>
                </div>
                <div class="controls-group">
                    <label for="qr-border-color">Border Color:</label>
                    <select id="qr-border-color"></select>
                </div>
            </div>
             <div class="button-group">
                <button id="download" style="display:none;">Download Dithered Image</button>
                <button id="sendToESP32" style="display: inline;">Send to Frame</button>
                <button id="downloadArray" style="display:none;">Download Data Array</button>
                <button id="switchToRealTime" style="display: inline;">Switch To Real-time Mode</button>
                <button id="switchToSlideShow" style="display: inline;">Switch To Slideshow Mode</button>
            </div>
            <div id="log"></div>
        </div>
        <canvas id="canvas" width="1200" height="1600"></canvas>
        <div class="back-to-top" onclick="window.scrollTo({top: 0, behavior: 'smooth'})">↑</div>
    </div>

    <script>
        // 固定6色调色板 / Fixed 6-color palette
        const rgbPalette = [
            { name: "Yellow", r: 255, g: 255, b: 0, value: 0xe2 },
            { name: "Green", r: 41, g: 204, b: 20, value: 0x96 },
            { name: "Blue", r: 0, g: 0, b: 255, value: 0x1d },
            { name: "Red", r: 255, g: 0, b: 0, value: 0x4c },
            { name: "Black", r: 0, g: 0, b: 0, value: 0x00 },
            { name: "White", r: 255, g: 255, b: 255, value: 0xff }
        ];

        // Populate QR color pickers
        const qrColorSelect = document.getElementById('qr-color');
        const qrBorderColorSelect = document.getElementById('qr-border-color');
        rgbPalette.forEach(color => {
            const option = new Option(color.name, `rgb(${color.r}, ${color.g}, ${color.b})`);
            qrColorSelect.add(option.cloneNode(true));
            qrBorderColorSelect.add(option);
        });
        qrColorSelect.value = 'rgb(0, 0, 0)'; // Default to black
        qrBorderColorSelect.value = 'rgb(255, 255, 255)'; // Default to white

        // 事件监听 / Event Listeners
        document.getElementById('upload').addEventListener('change', handleFileUpload);
        document.getElementById('download').addEventListener('click', downloadImage);
        document.getElementById('sendToESP32').addEventListener('click', sendToESP32);
        document.getElementById('downloadArray').addEventListener('click', downloadDataArray);
        document.getElementById('switchToRealTime').addEventListener('click', switchToRealTime);
        document.getElementById('switchToSlideShow').addEventListener('click', switchToSlideShow);
        document.getElementById('ditherStrength').addEventListener('input', updateImage);
        document.getElementById('contrast').addEventListener('input', updateImage);
        document.getElementById('ditherMode').addEventListener('change', updateImage);
        document.getElementById('ditherType').addEventListener('change', updateImage);
        document.getElementById('rotation').addEventListener('change', updateImage);

        // Health Check Logic
        const esp32IpInput = document.getElementById('esp32-ip');
        const onlineStatusIndicator = document.getElementById('online-status-indicator');
        const lastOnlineTimeSpan = document.getElementById('last-online-time');
        const lastCheckedTimeSpan = document.getElementById('last-checked-time');

        let healthCheckTimer;
        let currentCheckInterval = 5000; // Start with 5 seconds
        const maxCheckInterval = 30000; // 30 seconds
        const baseCheckInterval = 5000; // 5 seconds

        async function checkEsp32Status() {
            const ip = esp32IpInput.value.trim();
            if (!ip) {
                updateStatus(false, 'IP address is empty.');
                return;
            }

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 2000); // 2-second timeout

            lastCheckedTimeSpan.textContent = new Date().toLocaleTimeString();
            onlineStatusIndicator.classList.remove('online', 'offline'); // Set to neutral gray

            try {
                // We expect a 500 error from a healthy frame, which is not a network error.
                // Any response, even an error response, means the device is on the network.
                // Using 'no-cors' is crucial here. We can't inspect the response (e.g., check for status 500),
                // but a successful fetch (promise resolves) indicates the device is reachable on the network.
                // A network error (promise rejects) indicates it's offline. This avoids CORS issues
                // where the browser would block the request if the ESP32 doesn't send CORS headers.
                const response = await fetch(`http://${ip}/`, {
                    method: 'GET',
                    mode: 'no-cors', // Allows checking reachability without requiring CORS headers from the device
                    signal: controller.signal
                });
                 // If we get here, it's online, regardless of status code
                updateStatus(true);
            } catch (error) {
                // This catches network errors (e.g., unreachable host) or timeouts
                if (error.name === 'AbortError') {
                    updateStatus(false, 'Timeout');
                } else {
                    updateStatus(false, 'Offline');
                }
            } finally {
                clearTimeout(timeoutId);
                scheduleNextCheck();
            }
        }

        function updateStatus(isOnline, statusText = 'Unknown') {
            if (isOnline) {
                onlineStatusIndicator.classList.add('online');
                onlineStatusIndicator.classList.remove('offline');
                onlineStatusIndicator.title = 'Status: Online';
                lastOnlineTimeSpan.textContent = new Date().toLocaleTimeString();
                currentCheckInterval = baseCheckInterval; // Reset interval on success
            } else {
                onlineStatusIndicator.classList.add('offline');
                onlineStatusIndicator.classList.remove('online');
                onlineStatusIndicator.title = `Status: Offline (${statusText})`;
                // Double the interval on failure, up to the max
                currentCheckInterval = Math.min(currentCheckInterval * 2, maxCheckInterval);
            }
        }

        function scheduleNextCheck() {
            clearTimeout(healthCheckTimer);
            healthCheckTimer = setTimeout(checkEsp32Status, currentCheckInterval);
        }

        function startHealthChecks() {
            currentCheckInterval = baseCheckInterval; // Reset interval
            clearTimeout(healthCheckTimer);
            checkEsp32Status();
        }

        // Start checking when the page loads
        document.addEventListener('DOMContentLoaded', startHealthChecks);

        // And restart checks if the IP is changed
        esp32IpInput.addEventListener('change', startHealthChecks);


        // QR Code Event Listeners
        const qrCodeToggle = document.getElementById('qr-code-toggle');
        const qrCodeOptions = document.getElementById('qr-code-options');
        const qrContentType = document.getElementById('qr-content-type');
        const qrCustomTextContainer = document.getElementById('qr-custom-text-container');
        let qrDebounceTimer;

        function syncQrCodeOptionsVisibility() {
            qrCodeOptions.style.display = qrCodeToggle.checked ? 'block' : 'none';
        }

        qrCodeToggle.addEventListener('change', () => {
            syncQrCodeOptionsVisibility();
            updateImage();
        });

        document.addEventListener('DOMContentLoaded', () => {
            syncQrCodeOptionsVisibility();
        });

        qrContentType.addEventListener('change', () => {
            qrCustomTextContainer.style.display = qrContentType.value === 'custom' ? 'block' : 'none';
            if (qrContentType.value === 'custom') {
                document.getElementById('qr-custom-text').value = window.location.href;
            }
            updateImage();
        });

        const qrUpdateDebounced = () => {
            clearTimeout(qrDebounceTimer);
            qrDebounceTimer = setTimeout(updateImage, 500);
        };

        document.getElementById('qr-custom-text').addEventListener('input', qrUpdateDebounced);
        document.getElementById('qr-position').addEventListener('change', updateImage);
        document.getElementById('qr-margin').addEventListener('input', qrUpdateDebounced);
        document.getElementById('qr-color').addEventListener('change', updateImage);
        document.getElementById('qr-border-color').addEventListener('change', updateImage);

        document.getElementById('scaling').addEventListener('change', () => {
            const scalingMode = document.getElementById('scaling').value;
            const customScalingContainer = document.getElementById('custom-scaling-container');
            customScalingContainer.style.display = scalingMode === 'custom' ? 'flex' : 'none';
            updateImage();
        });

        const customScaleSlider = document.getElementById('customScale');
        const customScaleNumber = document.getElementById('customScaleNumber');

        let debounceTimer;

        // For the slider: update the number box on 'input', but only update the image on 'change' (on release)
        customScaleSlider.addEventListener('input', () => {
            const scaleValue = parseInt(customScaleSlider.value, 10);
            customScaleNumber.value = scaleValue;
            document.getElementById('scale-percentage').textContent = `(${scaleValue}%)`;
        });
        customScaleSlider.addEventListener('change', () => {
            updateImage();
        });

        // For the number input: use a debounce to avoid updating on every keystroke
        customScaleNumber.addEventListener('input', () => {
            const scaleValue = parseInt(customScaleNumber.value, 10);

            // Sync slider and percentage text immediately
            if (!isNaN(scaleValue) && scaleValue >= 10 && scaleValue <= 200) {
                customScaleSlider.value = scaleValue;
                document.getElementById('scale-percentage').textContent = `(${scaleValue}%)`;
            } else if (customScaleNumber.value === '') {
                 document.getElementById('scale-percentage').textContent = ``;
            }

            // Debounce the actual image update
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                if (!isNaN(scaleValue) && scaleValue >= 10 && scaleValue <= 200) {
                    updateImage();
                }
            }, 500);
        });

        // Quick-set buttons should update everything immediately.
        document.querySelectorAll('.quick-scale').forEach(button => {
            button.addEventListener('click', (e) => {
                const scaleValue = e.target.dataset.scale;
                customScaleSlider.value = scaleValue;
                customScaleNumber.value = scaleValue;
                document.getElementById('scale-percentage').textContent = `(${scaleValue}%)`;
                updateImage();

                // Also switch the dropdown to custom if another mode was selected
                document.getElementById('scaling').value = 'custom';
                document.getElementById('custom-scaling-container').style.display = 'flex';
            });
        });

        let originalImage = null;

        // 显示返回顶部按钮 / Show "Back to Top" button
        window.addEventListener('scroll', () => {
            const backToTop = document.querySelector('.back-to-top');
            backToTop.style.display = window.scrollY > 300 ? 'block' : 'none';
        });

        function handleFileUpload(event) {
            const file = event.target.files[0];
            event.target.value = '';
            const reader = new FileReader();

            reader.onload = function (e) {
                const img = new Image();
                img.onload = function () {
                    originalImage = img;
                    updateImage();

                    document.getElementById('sendToESP32').style.display = 'inline';
                    document.getElementById('switchToRealTime').style.display = 'inline';
                    document.getElementById('switchToSlideShow').style.display = 'inline';
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function updateImage() {
            if (!originalImage) return;

            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const rotation = parseInt(document.getElementById('rotation').value, 10);
            const scalingMode = document.getElementById('scaling').value;
            const scalePercentageSpan = document.getElementById('scale-percentage');

            // Create a temporary canvas to hold the rotated source image
            const rotatedCanvas = document.createElement('canvas');
            const rotatedCtx = rotatedCanvas.getContext('2d');

            if (rotation === 90 || rotation === 270) {
                rotatedCanvas.width = originalImage.height;
                rotatedCanvas.height = originalImage.width;
            } else {
                rotatedCanvas.width = originalImage.width;
                rotatedCanvas.height = originalImage.height;
            }

            rotatedCtx.translate(rotatedCanvas.width / 2, rotatedCanvas.height / 2);
            rotatedCtx.rotate(rotation * Math.PI / 180);
            rotatedCtx.drawImage(originalImage, -originalImage.width / 2, -originalImage.height / 2);

            const sourceImage = rotatedCanvas;

            const frameWidth = 1200;
            const frameHeight = 1600;
            const size8x10Scaler = 0.985;

            // Offscreen canvas for pre-processing
            const offscreenCanvas = document.createElement('canvas');
            offscreenCanvas.width = frameWidth;
            offscreenCanvas.height = frameHeight;
            const offscreenCtx = offscreenCanvas.getContext('2d');

            // Clear canvas with white background, so scaling to fit has a backdrop
            offscreenCtx.fillStyle = 'white';
            offscreenCtx.fillRect(0, 0, frameWidth, frameHeight);

            // 1. Draw original image to offscreen canvas with selected scaling
            let scale;
            const imageBoundingBox = { x: 0, y: 0, width: 0, height: 0 };

            let baseScale;
            switch (scalingMode) {
                case 'fit':
                case 'fit_8x10':
                    baseScale = Math.min(frameWidth / sourceImage.width, frameHeight / sourceImage.height);
                    scale = scalingMode === 'fit_8x10' ? baseScale * size8x10Scaler : baseScale;
                    imageBoundingBox.width = sourceImage.width * scale;
                    imageBoundingBox.height = sourceImage.height * scale;
                    imageBoundingBox.x = (frameWidth - imageBoundingBox.width) / 2;
                    imageBoundingBox.y = (frameHeight - imageBoundingBox.height) / 2;
                    offscreenCtx.drawImage(sourceImage, imageBoundingBox.x, imageBoundingBox.y, imageBoundingBox.width, imageBoundingBox.height);
                    break;
                case 'original':
                    scale = 1.0;
                    imageBoundingBox.width = sourceImage.width * scale;
                    imageBoundingBox.height = sourceImage.height * scale;
                    imageBoundingBox.x = (frameWidth - imageBoundingBox.width) / 2;
                    imageBoundingBox.y = (frameHeight - imageBoundingBox.height) / 2;
                    offscreenCtx.drawImage(sourceImage, imageBoundingBox.x, imageBoundingBox.y, imageBoundingBox.width, imageBoundingBox.height);
                    break;
                case 'custom':
                    const customScaleValue = parseInt(document.getElementById('customScale').value, 10);
                    scale = customScaleValue / 100;
                    imageBoundingBox.width = sourceImage.width * scale;
                    imageBoundingBox.height = sourceImage.height * scale;
                    imageBoundingBox.x = (frameWidth - imageBoundingBox.width) / 2;
                    imageBoundingBox.y = (frameHeight - imageBoundingBox.height) / 2;
                    offscreenCtx.drawImage(sourceImage, imageBoundingBox.x, imageBoundingBox.y, imageBoundingBox.width, imageBoundingBox.height);
                    break;
                case 'fill':
                case 'fill_8x10':
                default:
                    baseScale = Math.max(frameWidth / sourceImage.width, frameHeight / sourceImage.height);
                    scale = scalingMode === 'fill_8x10' ? baseScale * size8x10Scaler : baseScale;
                    const cropWidth = frameWidth / scale;
                    const cropHeight = frameHeight / scale;
                    const cropX = (sourceImage.width - cropWidth) / 2;
                    const cropY = (sourceImage.height - cropHeight) / 2;
                    offscreenCtx.drawImage(
                        sourceImage,
                        cropX, cropY,
                        cropWidth, cropHeight,
                        0, 0,
                        frameWidth, frameHeight
                    );
                    // For fill modes, the image bounding box is the full canvas
                    imageBoundingBox.x = 0;
                    imageBoundingBox.y = 0;
                    imageBoundingBox.width = frameWidth;
                    imageBoundingBox.height = frameHeight;
                    break;
            }

            // Update scale percentage display
            if (scalingMode !== 'custom') {
                 scalePercentageSpan.textContent = `(${(scale * 100).toFixed(1)}%)`;
            } else {
                const customScaleValue = parseInt(document.getElementById('customScale').value, 10);
                scalePercentageSpan.textContent = `(${customScaleValue}%)`;
            }


            // 2. Get image data and apply filters
            const imageData = offscreenCtx.getImageData(0, 0, frameWidth, frameHeight);
            const contrastFactor = parseFloat(document.getElementById('contrast').value);
            adjustContrast(imageData, contrastFactor);
            ditherImage(imageData);
            offscreenCtx.putImageData(imageData, 0, 0);

            // 3. Prepare main canvas and draw the processed offscreen canvas
            canvas.width = frameWidth;
            canvas.height = frameHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(offscreenCanvas, 0, 0);

            // 4. Draw QR Code if enabled
            drawQrCode(ctx, imageBoundingBox);
        }

        function getRotatedQrPosition(position, rotation) {
            const positions = ['top-left', 'top-right', 'bottom-right', 'bottom-left'];
            const currentIndex = positions.indexOf(position);

            // Calculate the rotation offset: 90 degrees = 1 step, 180 = 2, etc.
            const rotationOffset = rotation / 90;

            // Apply the offset and wrap around using modulo
            const newIndex = (currentIndex + rotationOffset) % 4;

            return positions[newIndex];
        }

        function drawQrCode(ctx, imageRect) {
            if (!document.getElementById('qr-code-toggle').checked) return;

            const contentType = document.getElementById('qr-content-type').value;
            let qrContent = '';

            switch (contentType) {
                case 'url':
                    qrContent = window.location.href;
                    break;
                case 'wifi':
                    qrContent = `WIFI:T:WPA;S:NeoFrame;P:123456789;H:false;`;
                    break;
                case 'custom':
                    qrContent = document.getElementById('qr-custom-text').value;
                    break;
                case 'exif':
                    EXIF.getData(originalImage, function() {
                        const allMetaData = EXIF.getAllTags(this);
                        let exifString = '';
                        for (let tag in allMetaData) {
                            if (allMetaData.hasOwnProperty(tag)) {
                                exifString += `${tag}: ${allMetaData[tag]}\n`;
                            }
                        }
                        qrContent = exifString || "No EXIF data found.";
                        generateAndDrawQrCode(ctx, qrContent, imageRect);
                    });
                    return;
            }

            generateAndDrawQrCode(ctx, qrContent, imageRect);
        }

        function generateAndDrawQrCode(ctx, content, imageRect) {
            const qrColor = document.getElementById('qr-color').value;
            const borderColor = document.getElementById('qr-border-color').value;
            const originalPosition = document.getElementById('qr-position').value;
            const rotation = parseInt(document.getElementById('rotation').value, 10);
            const position = getRotatedQrPosition(originalPosition, rotation);
            const margin = parseInt(document.getElementById('qr-margin').value, 10);

            try {
                const qr = qrcode(0, 'L');
                qr.addData(content);
                qr.make();

                const moduleCount = qr.getModuleCount();
                const moduleSize = 4;
                const qrSize = moduleCount * moduleSize;
                const borderSize = moduleSize;

                const qrCanvas = document.createElement('canvas');
                const qrCtx = qrCanvas.getContext('2d');
                qrCanvas.width = qrSize;
                qrCanvas.height = qrSize;

                for (let row = 0; row < moduleCount; row++) {
                    for (let col = 0; col < moduleCount; col++) {
                        if (qr.isDark(row, col)) {
                            qrCtx.fillStyle = qrColor;
                            qrCtx.fillRect(col * moduleSize, row * moduleSize, moduleSize, moduleSize);
                        }
                    }
                }

                const borderedCanvas = document.createElement('canvas');
                const borderedCtx = borderedCanvas.getContext('2d');
                const borderedSize = qrSize + (borderSize * 2);
                borderedCanvas.width = borderedSize;
                borderedCanvas.height = borderedSize;

                borderedCtx.fillStyle = borderColor;
                borderedCtx.fillRect(0, 0, borderedSize, borderedSize);
                borderedCtx.drawImage(qrCanvas, borderSize, borderSize);

                const visibleX1 = Math.max(0, imageRect.x);
                const visibleY1 = Math.max(0, imageRect.y);
                const visibleX2 = Math.min(imageRect.x + imageRect.width, ctx.canvas.width);
                const visibleY2 = Math.min(imageRect.y + imageRect.height, ctx.canvas.height);

                let x = 0, y = 0;
                switch (position) {
                    case 'bottom-right':
                        x = visibleX2 - borderedSize - margin;
                        y = visibleY2 - borderedSize - margin;
                        break;
                    case 'bottom-left':
                        x = visibleX1 + margin;
                        y = visibleY2 - borderedSize - margin;
                        break;
                    case 'top-right':
                        x = visibleX2 - borderedSize - margin;
                        y = visibleY1 + margin;
                        break;
                    case 'top-left':
                        x = visibleX1 + margin;
                        y = visibleY1 + margin;
                        break;
                }

                ctx.drawImage(borderedCanvas, x, y);

            } catch (e) {
                console.error("Error generating QR code:", e);
                ctx.fillStyle = 'red';
                ctx.font = '20px Arial';
                ctx.fillText('Error generating QR code', 10, 50);
            }
        }

        function adjustContrast(imageData, factor) {
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, Math.max(0, (data[i] - 128) * factor + 128));
                data[i + 1] = Math.min(255, Math.max(0, (data[i + 1] - 128) * factor + 128));
                data[i + 2] = Math.min(255, Math.max(0, (data[i + 2] - 128) * factor + 128));
            }
            return imageData;
        }

        function rgbToLab(r, g, b) {
            r = r / 255;
            g = g / 255;
            b = b / 255;

            r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
            g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
            b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

            r *= 100;
            g *= 100;
            b *= 100;

            let x = r * 0.4124 + g * 0.3576 + b * 0.1805;
            let y = r * 0.2126 + g * 0.7152 + b * 0.0722;
            let z = r * 0.0193 + g * 0.1192 + b * 0.9505;

            x /= 95.047;
            y /= 100.0;
            z /= 108.883;

            x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
            y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
            z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

            const l = (116 * y) - 16;
            const a = 500 * (x - y);
            const bLab = 200 * (y - z);

            return { l, a, b: bLab };
        }

        function labDistance(lab1, lab2) {
            const dl = lab1.l - lab2.l;
            const da = lab1.a - lab2.a;
            const db = lab1.b - lab2.b;
            return Math.sqrt(0.2 * dl * dl + 3 * da * da + 3 * db * db);
        }

        function findClosestColor(r, g, b) {
            if (r < 50 && g < 150 && b > 100) {
                return rgbPalette[2];
            }

            const inputLab = rgbToLab(r, g, b);
            let minDistance = Infinity;
            let closestColor = rgbPalette[0];

            for (const color of rgbPalette) {
                const colorLab = rgbToLab(color.r, color.g, color.b);
                const distance = labDistance(inputLab, colorLab);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = color;
                }
            }

            return closestColor;
        }

        function floydSteinbergDither(imageData, strength) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            const tempData = new Uint8ClampedArray(data);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = tempData[idx];
                    const g = tempData[idx + 1];
                    const b = tempData[idx + 2];

                    const closest = findClosestColor(r, g, b);

                    const errR = (r - closest.r) * strength;
                    const errG = (g - closest.g) * strength;
                    const errB = (b - closest.b) * strength;

                    if (x + 1 < width) {
                        const idxRight = idx + 4;
                        tempData[idxRight] = Math.min(255, Math.max(0, tempData[idxRight] + errR * 7 / 16));
                        tempData[idxRight + 1] = Math.min(255, Math.max(0, tempData[idxRight + 1] + errG * 7 / 16));
                        tempData[idxRight + 2] = Math.min(255, Math.max(0, tempData[idxRight + 2] + errB * 7 / 16));
                    }
                    if (y + 1 < height) {
                        if (x > 0) {
                            const idxDownLeft = idx + width * 4 - 4;
                            tempData[idxDownLeft] = Math.min(255, Math.max(0, tempData[idxDownLeft] + errR * 3 / 16));
                            tempData[idxDownLeft + 1] = Math.min(255, Math.max(0, tempData[idxDownLeft + 1] + errG * 3 / 16));
                            tempData[idxDownLeft + 2] = Math.min(255, Math.max(0, tempData[idxDownLeft + 2] + errB * 3 / 16));
                        }
                        const idxDown = idx + width * 4;
                        tempData[idxDown] = Math.min(255, Math.max(0, tempData[idxDown] + errR * 5 / 16));
                        tempData[idxDown + 1] = Math.min(255, Math.max(0, tempData[idxDown + 1] + errG * 5 / 16));
                        tempData[idxDown + 2] = Math.min(255, Math.max(0, tempData[idxDown + 2] + errB * 5 / 16));
                        if (x + 1 < width) {
                            const idxDownRight = idx + width * 4 + 4;
                            tempData[idxDownRight] = Math.min(255, Math.max(0, tempData[idxDownRight] + errR * 1 / 16));
                            tempData[idxDownRight + 1] = Math.min(255, Math.max(0, tempData[idxDownRight + 1] + errG * 1 / 16));
                            tempData[idxDownRight + 2] = Math.min(255, Math.max(0, tempData[idxDownRight + 2] + errB * 1 / 16));
                        }
                    }
                }
            }

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = tempData[idx];
                    const g = tempData[idx + 1];
                    const b = tempData[idx + 2];

                    const closest = findClosestColor(r, g, b);
                    data[idx] = closest.r;
                    data[idx + 1] = closest.g;
                    data[idx + 2] = closest.b;
                }
            }

            return imageData;
        }

        function atkinsonDither(imageData, strength) {
    const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    const tempData = new Uint8ClampedArray(data);

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const idx = (y * width + x) * 4;
            const r = tempData[idx];
            const g = tempData[idx + 1];
            const b = tempData[idx + 2];

            // 找到最近的调色板颜色 / Find the closest palette color
            const closest = findClosestColor(r, g, b);

            // 直接更新当前像素颜色到调色板颜色 / Directly update the current pixel color to the palette color
            data[idx] = closest.r;
            data[idx + 1] = closest.g;
            data[idx + 2] = closest.b;

            // 计算误差并按Atkinson算法扩散 / Calculate the error and diffuse it using the Atkinson algorithm
            const errR = (r - closest.r) * strength;
            const errG = (g - closest.g) * strength;
            const errB = (b - closest.b) * strength;

            const fraction = 1 / 8;

            // 向右1像素 / To the right 1 pixel
            if (x + 1 < width) {
                const idxRight = idx + 4;
                tempData[idxRight] = Math.min(255, Math.max(0, tempData[idxRight] + errR * fraction));
                tempData[idxRight + 1] = Math.min(255, Math.max(0, tempData[idxRight + 1] + errG * fraction));
                tempData[idxRight + 2] = Math.min(255, Math.max(0, tempData[idxRight + 2] + errB * fraction));
            }
            // 向右2像素 / To the right 2 pixels
            if (x + 2 < width) {
                const idxRight2 = idx + 8;
                tempData[idxRight2] = Math.min(255, Math.max(0, tempData[idxRight2] + errR * fraction));
                tempData[idxRight2 + 1] = Math.min(255, Math.max(0, tempData[idxRight2 + 1] + errG * fraction));
                tempData[idxRight2 + 2] = Math.min(255, Math.max(0, tempData[idxRight2 + 2] + errB * fraction));
            }
            // 向下1行 / Down 1 row
            if (y + 1 < height) {
                // 左1像素 / Left 1 pixel
                if (x > 0) {
                    const idxDownLeft = idx + width * 4 - 4;
                    tempData[idxDownLeft] = Math.min(255, Math.max(0, tempData[idxDownLeft] + errR * fraction));
                    tempData[idxDownLeft + 1] = Math.min(255, Math.max(0, tempData[idxDownLeft + 1] + errG * fraction));
                    tempData[idxDownLeft + 2] = Math.min(255, Math.max(0, tempData[idxDownLeft + 2] + errB * fraction));
                }
                // 正下方 / Directly below
                const idxDown = idx + width * 4;
                tempData[idxDown] = Math.min(255, Math.max(0, tempData[idxDown] + errR * fraction));
                tempData[idxDown + 1] = Math.min(255, Math.max(0, tempData[idxDown + 1] + errG * fraction));
                tempData[idxDown + 2] = Math.min(255, Math.max(0, tempData[idxDown + 2] + errB * fraction));
                // 右1像素 / Right 1 pixel
                if (x + 1 < width) {
                    const idxDownRight = idx + width * 4 + 4;
                    tempData[idxDownRight] = Math.min(255, Math.max(0, tempData[idxDownRight] + errR * fraction));
                    tempData[idxDownRight + 1] = Math.min(255, Math.max(0, tempData[idxDownRight + 1] + errG * fraction));
                    tempData[idxDownRight + 2] = Math.min(255, Math.max(0, tempData[idxDownRight + 2] + errB * fraction));
                }
            }
            // 向下2行 / Down 2 rows
            if (y + 2 < height) {
                const idxDown2 = idx + width * 8;
                tempData[idxDown2] = Math.min(255, Math.max(0, tempData[idxDown2] + errR * fraction));
                tempData[idxDown2 + 1] = Math.min(255, Math.max(0, tempData[idxDown2 + 1] + errG * fraction));
                tempData[idxDown2 + 2] = Math.min(255, Math.max(0, tempData[idxDown2 + 2] + errB * fraction));
            }
        }
    }

    return imageData;
}

        function stuckiDither(imageData, strength) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            const tempData = new Uint8ClampedArray(data);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = tempData[idx];
                    const g = tempData[idx + 1];
                    const b = tempData[idx + 2];

                    const closest = findClosestColor(r, g, b);

                    const errR = (r - closest.r) * strength;
                    const errG = (g - closest.g) * strength;
                    const errB = (b - closest.b) * strength;

                    const divisor = 42;

                    if (x + 1 < width) {
                        const idxRight = idx + 4;
                        tempData[idxRight] = Math.min(255, Math.max(0, tempData[idxRight] + errR * 8 / divisor));
                        tempData[idxRight + 1] = Math.min(255, Math.max(0, tempData[idxRight + 1] + errG * 8 / divisor));
                        tempData[idxRight + 2] = Math.min(255, Math.max(0, tempData[idxRight + 2] + errB * 8 / divisor));
                    }
                    if (x + 2 < width) {
                        const idxRight2 = idx + 8;
                        tempData[idxRight2] = Math.min(255, Math.max(0, tempData[idxRight2] + errR * 4 / divisor));
                        tempData[idxRight2 + 1] = Math.min(255, Math.max(0, tempData[idxRight2 + 1] + errG * 4 / divisor));
                        tempData[idxRight2 + 2] = Math.min(255, Math.max(0, tempData[idxRight2 + 2] + errB * 4 / divisor));
                    }
                    if (y + 1 < height) {
                        if (x > 1) {
                            const idxDownLeft2 = idx + width * 4 - 8;
                            tempData[idxDownLeft2] = Math.min(255, Math.max(0, tempData[idxDownLeft2] + errR * 2 / divisor));
                            tempData[idxDownLeft2 + 1] = Math.min(255, Math.max(0, tempData[idxDownLeft2 + 1] + errG * 2 / divisor));
                            tempData[idxDownLeft2 + 2] = Math.min(255, Math.max(0, tempData[idxDownLeft2 + 2] + errB * 2 / divisor));
                        }
                        if (x > 0) {
                            const idxDownLeft = idx + width * 4 - 4;
                            tempData[idxDownLeft] = Math.min(255, Math.max(0, tempData[idxDownLeft] + errR * 4 / divisor));
                            tempData[idxDownLeft + 1] = Math.min(255, Math.max(0, tempData[idxDownLeft + 1] + errG * 4 / divisor));
                            tempData[idxDownLeft + 2] = Math.min(255, Math.max(0, tempData[idxDownLeft + 2] + errB * 4 / divisor));
                        }
                        const idxDown = idx + width * 4;
                        tempData[idxDown] = Math.min(255, Math.max(0, tempData[idxDown] + errR * 8 / divisor));
                        tempData[idxDown + 1] = Math.min(255, Math.max(0, tempData[idxDown + 1] + errG * 8 / divisor));
                        tempData[idxDown + 2] = Math.min(255, Math.max(0, tempData[idxDown + 2] + errB * 8 / divisor));
                        if (x + 1 < width) {
                            const idxDownRight = idx + width * 4 + 4;
                            tempData[idxDownRight] = Math.min(255, Math.max(0, tempData[idxDownRight] + errR * 4 / divisor));
                            tempData[idxDownRight + 1] = Math.min(255, Math.max(0, tempData[idxDownRight + 1] + errG * 4 / divisor));
                            tempData[idxDownRight + 2] = Math.min(255, Math.max(0, tempData[idxDownRight + 2] + errB * 4 / divisor));
                        }
                        if (x + 2 < width) {
                            const idxDownRight2 = idx + width * 4 + 8;
                            tempData[idxDownRight2] = Math.min(255, Math.max(0, tempData[idxDownRight2] + errR * 2 / divisor));
                            tempData[idxDownRight2 + 1] = Math.min(255, Math.max(0, tempData[idxDownRight2 + 1] + errG * 2 / divisor));
                            tempData[idxDownRight2 + 2] = Math.min(255, Math.max(0, tempData[idxDownRight2 + 2] + errB * 2 / divisor));
                        }
                    }
                    if (y + 2 < height) {
                        if (x > 1) {
                            const idxDown2Left2 = idx + width * 8 - 8;
                            tempData[idxDown2Left2] = Math.min(255, Math.max(0, tempData[idxDown2Left2] + errR * 1 / divisor));
                            tempData[idxDown2Left2 + 1] = Math.min(255, Math.max(0, tempData[idxDown2Left2 + 1] + errG * 1 / divisor));
                            tempData[idxDown2Left2 + 2] = Math.min(255, Math.max(0, tempData[idxDown2Left2 + 2] + errB * 1 / divisor));
                        }
                        if (x > 0) {
                            const idxDown2Left = idx + width * 8 - 4;
                            tempData[idxDown2Left] = Math.min(255, Math.max(0, tempData[idxDown2Left] + errR * 2 / divisor));
                            tempData[idxDown2Left + 1] = Math.min(255, Math.max(0, tempData[idxDown2Left + 1] + errG * 2 / divisor));
                            tempData[idxDown2Left + 2] = Math.min(255, Math.max(0, tempData[idxDown2Left + 2] + errB * 2 / divisor));
                        }
                        const idxDown2 = idx + width * 8;
                        tempData[idxDown2] = Math.min(255, Math.max(0, tempData[idxDown2] + errR * 4 / divisor));
                        tempData[idxDown2 + 1] = Math.min(255, Math.max(0, tempData[idxDown2 + 1] + errG * 4 / divisor));
                        tempData[idxDown2 + 2] = Math.min(255, Math.max(0, tempData[idxDown2 + 2] + errB * 4 / divisor));
                        if (x + 1 < width) {
                            const idxDown2Right = idx + width * 8 + 4;
                            tempData[idxDown2Right] = Math.min(255, Math.max(0, tempData[idxDown2Right] + errR * 2 / divisor));
                            tempData[idxDown2Right + 1] = Math.min(255, Math.max(0, tempData[idxDown2Right + 1] + errG * 2 / divisor));
                            tempData[idxDown2Right + 2] = Math.min(255, Math.max(0, tempData[idxDown2Right + 2] + errB * 2 / divisor));
                        }
                        if (x + 2 < width) {
                            const idxDown2Right2 = idx + width * 8 + 8;
                            tempData[idxDown2Right2] = Math.min(255, Math.max(0, tempData[idxDown2Right2] + errR * 1 / divisor));
                            tempData[idxDown2Right2 + 1] = Math.min(255, Math.max(0, tempData[idxDown2Right2 + 1] + errG * 1 / divisor));
                            tempData[idxDown2Right2 + 2] = Math.min(255, Math.max(0, tempData[idxDown2Right2 + 2] + errB * 1 / divisor));
                        }
                    }
                }
            }

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = tempData[idx];
                    const g = tempData[idx + 1];
                    const b = tempData[idx + 2];

                    const closest = findClosestColor(r, g, b);
                    data[idx] = closest.r;
                    data[idx + 1] = closest.g;
                    data[idx + 2] = closest.b;
                }
            }

            return imageData;
        }

        function jarvisDither(imageData, strength) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            const tempData = new Uint8ClampedArray(data);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = tempData[idx];
                    const g = tempData[idx + 1];
                    const b = tempData[idx + 2];

                    const closest = findClosestColor(r, g, b);

                    const errR = (r - closest.r) * strength;
                    const errG = (g - closest.g) * strength;
                    const errB = (b - closest.b) * strength;

                    const divisor = 48;

                    if (x + 1 < width) {
                        const idxRight = idx + 4;
                        tempData[idxRight] = Math.min(255, Math.max(0, tempData[idxRight] + errR * 7 / divisor));
                        tempData[idxRight + 1] = Math.min(255, Math.max(0, tempData[idxRight + 1] + errG * 7 / divisor));
                        tempData[idxRight + 2] = Math.min(255, Math.max(0, tempData[idxRight + 2] + errB * 7 / divisor));
                    }
                    if (x + 2 < width) {
                        const idxRight2 = idx + 8;
                        tempData[idxRight2] = Math.min(255, Math.max(0, tempData[idxRight2] + errR * 5 / divisor));
                        tempData[idxRight2 + 1] = Math.min(255, Math.max(0, tempData[idxRight2 + 1] + errG * 5 / divisor));
                        tempData[idxRight2 + 2] = Math.min(255, Math.max(0, tempData[idxRight2 + 2] + errB * 5 / divisor));
                    }
                    if (y + 1 < height) {
                        if (x > 1) {
                            const idxDownLeft2 = idx + width * 4 - 8;
                            tempData[idxDownLeft2] = Math.min(255, Math.max(0, tempData[idxDownLeft2] + errR * 3 / divisor));
                            tempData[idxDownLeft2 + 1] = Math.min(255, Math.max(0, tempData[idxDownLeft2 + 1] + errG * 3 / divisor));
                            tempData[idxDownLeft2 + 2] = Math.min(255, Math.max(0, tempData[idxDownLeft2 + 2] + errB * 3 / divisor));
                        }
                        if (x > 0) {
                            const idxDownLeft = idx + width * 4 - 4;
                            tempData[idxDownLeft] = Math.min(255, Math.max(0, tempData[idxDownLeft] + errR * 5 / divisor));
                            tempData[idxDownLeft + 1] = Math.min(255, Math.max(0, tempData[idxDownLeft + 1] + errG * 5 / divisor));
                            tempData[idxDownLeft + 2] = Math.min(255, Math.max(0, tempData[idxDownLeft + 2] + errB * 5 / divisor));
                        }
                        const idxDown = idx + width * 4;
                        tempData[idxDown] = Math.min(255, Math.max(0, tempData[idxDown] + errR * 7 / divisor));
                        tempData[idxDown + 1] = Math.min(255, Math.max(0, tempData[idxDown + 1] + errG * 7 / divisor));
                        tempData[idxDown + 2] = Math.min(255, Math.max(0, tempData[idxDown + 2] + errB * 7 / divisor));
                        if (x + 1 < width) {
                            const idxDownRight = idx + width * 4 + 4;
                            tempData[idxDownRight] = Math.min(255, Math.max(0, tempData[idxDownRight] + errR * 5 / divisor));
                            tempData[idxDownRight + 1] = Math.min(255, Math.max(0, tempData[idxDownRight + 1] + errG * 5 / divisor));
                            tempData[idxDownRight + 2] = Math.min(255, Math.max(0, tempData[idxDownRight + 2] + errB * 5 / divisor));
                        }
                        if (x + 2 < width) {
                            const idxDownRight2 = idx + width * 4 + 8;
                            tempData[idxDownRight2] = Math.min(255, Math.max(0, tempData[idxDownRight2] + errR * 3 / divisor));
                            tempData[idxDownRight2 + 1] = Math.min(255, Math.max(0, tempData[idxDownRight2 + 1] + errG * 3 / divisor));
                            tempData[idxDownRight2 + 2] = Math.min(255, Math.max(0, tempData[idxDownRight2 + 2] + errB * 3 / divisor));
                        }
                    }
                    if (y + 2 < height) {
                        if (x > 1) {
                            const idxDown2Left2 = idx + width * 8 - 8;
                            tempData[idxDown2Left2] = Math.min(255, Math.max(0, tempData[idxDown2Left2] + errR * 1 / divisor));
                            tempData[idxDown2Left2 + 1] = Math.min(255, Math.max(0, tempData[idxDown2Left2 + 1] + errG * 1 / divisor));
                            tempData[idxDown2Left2 + 2] = Math.min(255, Math.max(0, tempData[idxDown2Left2 + 2] + errB * 1 / divisor));
                        }
                        if (x > 0) {
                            const idxDown2Left = idx + width * 8 - 4;
                            tempData[idxDown2Left] = Math.min(255, Math.max(0, tempData[idxDown2Left] + errR * 3 / divisor));
                            tempData[idxDown2Left + 1] = Math.min(255, Math.max(0, tempData[idxDown2Left + 1] + errG * 3 / divisor));
                            tempData[idxDown2Left + 2] = Math.min(255, Math.max(0, tempData[idxDown2Left + 2] + errB * 3 / divisor));
                        }
                        const idxDown2 = idx + width * 8;
                        tempData[idxDown2] = Math.min(255, Math.max(0, tempData[idxDown2] + errR * 5 / divisor));
                        tempData[idxDown2 + 1] = Math.min(255, Math.max(0, tempData[idxDown2 + 1] + errG * 5 / divisor));
                        tempData[idxDown2 + 2] = Math.min(255, Math.max(0, tempData[idxDown2 + 2] + errB * 5 / divisor));
                        if (x + 1 < width) {
                            const idxDown2Right = idx + width * 8 + 4;
                            tempData[idxDown2Right] = Math.min(255, Math.max(0, tempData[idxDown2Right] + errR * 3 / divisor));
                            tempData[idxDown2Right + 1] = Math.min(255, Math.max(0, tempData[idxDown2Right + 1] + errG * 3 / divisor));
                            tempData[idxDown2Right + 2] = Math.min(255, Math.max(0, tempData[idxDown2Right + 2] + errB * 3 / divisor));
                        }
                        if (x + 2 < width) {
                            const idxDown2Right2 = idx + width * 8 + 8;
                            tempData[idxDown2Right2] = Math.min(255, Math.max(0, tempData[idxDown2Right2] + errR * 1 / divisor));
                            tempData[idxDown2Right2 + 1] = Math.min(255, Math.max(0, tempData[idxDown2Right2 + 1] + errG * 1 / divisor));
                            tempData[idxDown2Right2 + 2] = Math.min(255, Math.max(0, tempData[idxDown2Right2 + 2] + errB * 1 / divisor));
                        }
                    }
                }
            }

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = tempData[idx];
                    const g = tempData[idx + 1];
                    const b = tempData[idx + 2];

                    const closest = findClosestColor(r, g, b);
                    data[idx] = closest.r;
                    data[idx + 1] = closest.g;
                    data[idx + 2] = closest.b;
                }
            }

            return imageData;
        }

        function ditherImage(imageData) {
            const ditherType = document.getElementById('ditherType').value;
            const ditherStrength = parseFloat(document.getElementById('ditherStrength').value);

            switch (ditherType) {
                case 'floydSteinberg':
                    return floydSteinbergDither(imageData, ditherStrength);
                case 'atkinson':
                    return atkinsonDither(imageData, ditherStrength);
                case 'stucki':
                    return stuckiDither(imageData, ditherStrength);
                case 'jarvis':
                    return jarvisDither(imageData, ditherStrength);
                default:
                    return imageData;
            }
        }

        function processImageData(imageData) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            let processedData;
            console.log("Image Data Length:", data.length);
  for (let i = 0; i < Math.min(data.length, 240000); i += 4) {
    console.log(`Pixel ${i / 4}: R=${data[i]}, G=${data[i+1]}, B=${data[i+2]}, A=${data[i+3]}`);
  }
            const mode = document.getElementById('ditherMode').value;



if (mode === 'sixColor') {
    const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    const processedData = new Uint8Array(Math.ceil((width * height) / 2));  // 每个字节存储2个像素 / Each byte stores 2 pixels

    // 将 RGB 转换为 6 色模式 / Convert RGB to 6-color mode
    function rgbToSixColor(r, g, b) {
        if (r < 128 && g < 128 && b < 128) return 0x00;  // 黑色 / Black
        if (r > 128 && g > 128 && b > 128) return 0x01;  // 白色 / White
        if (r > 128 && g < 128 && b < 128) return 0x03;  // 红色 / Red
        if (r > 128 && g > 128 && b < 128) return 0x02;  // 黄色 / Yellow
        if (r < 128 && g > 128 && b < 128) return 0x06;  // 绿色 / Green
        if (r < 128 && g < 128 && b > 128) return 0x05;  // 蓝色 / Blue
        return 0x01;  // 默认白色 / Default white
    }

    // 处理图像数据 / Process image data
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x += 2) { // 每两个像素处理一次 / Process two pixels at a time
            const index1 = (y * width + x) * 4;       // 第一个像素的索引 / Index of the first pixel
            const index2 = (y * width + x + 1) * 4;   // 第二个像素的索引 / Index of the second pixel

            // 获取两个像素的颜色值 / Get the color values of the two pixels
            const r1 = data[index1];
            const g1 = data[index1 + 1];
            const b1 = data[index1 + 2];

            const r2 = data[index2];
            const g2 = data[index2 + 1];
            const b2 = data[index2 + 2];

            // 将 RGB 转换为 6 色模式 / Convert RGB to 6-color mode
            const colorValue1 = rgbToSixColor(r1, g1, b1);
            const colorValue2 = rgbToSixColor(r2, g2, b2);

            // 组合成一个字节，每两个4位颜色值组成一个字节 / Combine into one byte, two 4-bit color values form one byte
            const combinedValue = (colorValue1 << 4) | colorValue2;

            // 计算在 processedData 中的索引 / Calculate the index in processedData
            const newIndex = (y * (width / 2)) + (x / 2);
            processedData[newIndex] = combinedValue;
        }
    }

  

    return processedData;
}
                 
            else if (mode === 'fourColor') {
                const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    const processedData = new Uint8Array(Math.ceil((width * height) / 4));  // 计算4灰度模式的数组大小 / Calculate the array size for 4-grayscale mode

    // 将RGB颜色转换为4灰度模式中的灰度值 / Convert RGB color to grayscale value in 4-grayscale mode
    function rgbToGray(r, g, b) {
        const grayscale = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
        if (grayscale < 64) return 0x03;  // 黑色 / Black
        if (grayscale < 128) return 0x02; // 红色 / Red
        if (grayscale < 140) return 0x00; // 黄色 / Yellow
        if (grayscale < 255) return 0x01; // 白色 / White
    }

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = (y * width + x) * 4;
            const r = data[index];
            const g = data[index + 1];
            const b = data[index + 2];
            const a = data[index + 3];  // 透明度值 / Alpha value
            const grayValue = rgbToGray(r, g, b);
            // 垂直翻转 / Vertical flip
           // const newIndex = ((height - 1 - y) * width + x) / 4 | 0;
           const newIndex = (y * width + x) / 4 | 0;
            // 将灰度值存储到processedData中 / Store the grayscale value in processedData
            const shift = 6 - ((x % 4) * 2);  // 计算每个像素在字节中的位置 / Calculate the position of each pixel in the byte
            processedData[newIndex] |= (grayValue << shift);
        }
    }

    return processedData;  // 返回的数组大小是 15,000 字节 / The returned array size is 15,000 bytes
        }
      else if (mode === 'blackWhiteColor') {
        const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    const byteWidth = Math.ceil(width / 8);  // 计算每行字节的宽度 / Calculate the width of each row in bytes
    const processedData = new Uint8Array(byteWidth * height);

    // 设置黑白转换的阈值 / Set the threshold for black and white conversion
    const threshold = 140;  // 你可以调整这个阈值来改变黑白分界线 / You can adjust this threshold to change the black and white dividing line

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = (y * width + x) * 4;
            const r = data[index];
            const g = data[index + 1];
            const b = data[index + 2];
            // 计算灰度值 / Calculate grayscale value
            const grayscale = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
            // 根据阈值决定黑白 / Determine black or white based on the threshold
            const bit = grayscale >= threshold ? 1 : 0;
            // 计算当前字节中的位置 / Calculate the position in the current byte
            const byteIndex = y * byteWidth + Math.floor(x / 8);
            const bitIndex = 7 - (x % 8);  // 从高位到低位 / From high bit to low bit
            // 设置相应的位 / Set the corresponding bit
            processedData[byteIndex] |= (bit << bitIndex);
        }
    }

    return processedData;
   
    }    else if (mode === 'threeColor') {
    const byteWidth = Math.ceil(width / 8); // 每个像素占用1位，一个字节可以存储8个像素 / Each pixel occupies 1 bit, one byte can store 8 pixels
    const blackWhiteThreshold = 140;  // 黑白阈值 / Black and white threshold
    const redThreshold = 160;  // 红色阈值 / Red threshold

    // 创建两个 Uint8Array 用于存储黑白和红白数据 / Create two Uint8Arrays to store black-and-white and red-and-white data
    const blackWhiteData = new Uint8Array(height * byteWidth);
    const redWhiteData = new Uint8Array(height * byteWidth);

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = (y * width + x) * 4;
            const r = data[index];
            const g = data[index + 1];
            const b = data[index + 2];
            const grayscale = Math.round(0.299 * r + 0.587 * g + 0.114 * b);

            // 黑白处理 / Black and white processing
            const blackWhiteBit = grayscale >= blackWhiteThreshold ? 1 : 0; // 1表示白色，0表示黑色 / 1 means white, 0 means black
            const blackWhiteByteIndex = y * byteWidth + Math.floor(x / 8);
            const blackWhiteBitIndex = 7 - (x % 8);
            if (blackWhiteBit) {
                blackWhiteData[blackWhiteByteIndex] |= (0x01 << blackWhiteBitIndex);  // 写入白色 / Write white
            } else {
                blackWhiteData[blackWhiteByteIndex] &= ~(0x01 << blackWhiteBitIndex);  // 写入黑色 / Write black
            }

            // 红白处理 / Red and white processing
            // 使用红色和白色的组合逻辑 / Use red and white combination logic
            const redWhiteBit = (r > redThreshold && r > g && r > b) ? 0 : 1; // 0表示红色，1表示白色 / 0 means red, 1 means white
            const redWhiteByteIndex = y * byteWidth + Math.floor(x / 8);
            const redWhiteBitIndex = 7 - (x % 8);
            if (redWhiteBit) {
                redWhiteData[redWhiteByteIndex] |= (0x01 << redWhiteBitIndex);  // 写入白色数据位为1 / Write white data bit as 1
            } else {
                redWhiteData[redWhiteByteIndex] &= ~(0x01 << redWhiteBitIndex);  // 写入红色数据位为0 / Write red data bit as 0
            }
        }
    }

    // 合并两个数组 / Merge the two arrays
    const processedData = new Uint8Array(blackWhiteData.length + redWhiteData.length);
    processedData.set(blackWhiteData, 0);  // 将黑白数据放在前半部分 / Put the black and white data in the first half
    processedData.set(redWhiteData, blackWhiteData.length);  // 将红白数据放在后半部分 / Put the red and white data in the second half

    console.log("BlackWhiteData:", blackWhiteData);
    console.log("RedWhiteData:", redWhiteData);
    console.log("ProcessedData:", processedData);

    return processedData;
}

}

        function downloadImage() {
            const canvas = document.getElementById('canvas');
            const dataURL = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = 'dithered_image.png';
            link.click();
        }

        async function sendToESP32() {
            updateStatus(true); // Proactively set status to online
            clearTimeout(healthCheckTimer); // Pause health checks

            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const processedData = processImageData(imageData);
            const esp32IP = document.getElementById('esp32-ip').value.trim() || '192.168.4.1';
            const CHUNK_SIZE = 960000;
            const DELAY_TIME = 5000;

            if (!esp32IP) {
                alert('Please enter the IP address of the ESP32 first');
                startHealthChecks(); // Resume health checks if IP is missing
                return;
            }

            try {
                const totalChunks = Math.ceil(processedData.length / CHUNK_SIZE);
                for (let i = 0; i < totalChunks; i++) {
                    const chunk = processedData.slice(i * CHUNK_SIZE, (i + 1) * CHUNK_SIZE);
                    const blob = new Blob([chunk], { type: 'application/octet-stream' });

                    const formData = new FormData();
                    formData.append('data', blob, 'image_data.bin');

                    const response = await fetch(`http://${esp32IP}/upload`, {
                        method: 'POST',
                        body: formData,
                        mode: 'cors'
                    });

                    if (!response.ok) {
                        throw new Error(`Error: ${response.statusText}`);
                    }

                    const responseText = await response.text();
                    console.log(`Server response: ${responseText}`);

                    // "文件上传成功" means "File uploaded successfully"
                    if (responseText.includes("文件上传成功")) {
                        alert('Image data has been successfully uploaded to ESP32.');
                        break;
                    }

                    await new Promise(resolve => setTimeout(resolve, DELAY_TIME));
                }
            } catch (error) {
                console.error('Failed to send data:', error);
                alert('Unable to send data to ESP32 via Wi-Fi');
            } finally {
                startHealthChecks(); // Always resume health checks
            }
        }

        async function switchToRealTime() {
            updateStatus(true); // Proactively set status to online
            clearTimeout(healthCheckTimer); // Pause health checks

            const esp32IP = document.getElementById('esp32-ip').value.trim() || '192.168.4.1';
            if (!esp32IP) {
                alert('Please enter the IP address of ESP32 first');
                startHealthChecks(); // Resume health checks if IP is missing
                return;
            }
            try {
                const response = await fetch(`http://${esp32IP}/switchToRealTime`, {
                    method: 'POST',
                    mode: 'cors'
                });
                if (!response.ok) {
                    throw new Error(`Error: ${response.statusText}`);
                }
                const responseText = await response.text();
                console.log(`Server response: ${responseText}`);
                // "切换到实时模式成功" means "Switched to real-time mode successfully"
                if (responseText.includes("切换到实时模式成功")) {
                    alert('Successfully switched to real-time mode');
                }
            } catch (error) {
                console.error('Failed to switch to real-time mode:', error);
                alert('Failed to switch to real-time mode');
            } finally {
                startHealthChecks(); // Always resume health checks
            }
        }

        async function switchToSlideShow() {
            updateStatus(true); // Proactively set status to online
            clearTimeout(healthCheckTimer); // Pause health checks

            const esp32IP = document.getElementById('esp32-ip').value.trim() || '192.168.4.1';
            if (!esp32IP) {
                alert('Please enter the ESP32 IP address first');
                startHealthChecks(); // Resume health checks if IP is missing
                return;
            }
            try {
                const response = await fetch(`http://${esp32IP}/switchToSlideShow`, {
                    method: 'POST',
                    mode: 'cors'
                });
                if (!response.ok) {
                    throw new Error(`Error: ${response.statusText}`);
                }
                const responseText = await response.text();
                console.log(`Server response: ${responseText}`);
                // "切换到轮播模式成功" means "Switched to slideshow mode successfully"
                if (responseText.includes("切换到轮播模式成功")) {
                    alert('Successfully switched to slideshow mode');
                }
            } catch (error) {
                console.error('Failed to switch to slideshow mode:', error);
                alert('Failed to switch to slideshow mode');
            } finally {
                startHealthChecks(); // Always resume health checks
            }
        }

        function downloadDataArray() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const processedData = processImageData(imageData);

            let dataString = 'const unsigned char gImage[] = {\n';
            for (let i = 0; i < processedData.length; i++) {
                dataString += `0x${processedData[i].toString(16).padStart(2, '0')}`;
                if (i !== processedData.length - 1) dataString += ', ';
                if ((i + 1) % 16 === 0) dataString += '\n';
            }
            dataString += '\n};';

            const blob = new Blob([dataString], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);

            const link = document.createElement('a');
            link.download = 'image_data_array.c';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }
    </script>

</body></html>